"""
Dynamic Hedging System
Implements portfolio hedging strategies to manage downside risk
"""

import numpy as np\nimport pandas as pd\nimport logging\nfrom typing import Dict, List, Optional, Tuple\nfrom datetime import datetime, timedelta\nfrom dataclasses import dataclass\n\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass HedgeRecommendation:\n    \"\"\"Hedge recommendation structure\"\"\"\n    hedge_type: str\n    symbol: str\n    side: str\n    size: float\n    hedge_ratio: float\n    reason: str\n    urgency: str\n    expected_cost: float\n    expected_protection: float\n\nclass DynamicHedgingSystem:\n    \"\"\"Dynamic portfolio hedging system\"\"\"\n    \n    def __init__(self):\n        self.hedge_positions = {}\n        self.hedge_history = []\n        \n        # Hedging parameters\n        self.hedge_thresholds = {\n            'portfolio_beta_threshold': 1.2,  # Hedge when portfolio beta > 1.2\n            'correlation_threshold': 0.8,     # Hedge when correlation > 0.8\n            'volatility_threshold': 0.25,     # Hedge when volatility > 25%\n            'drawdown_threshold': 0.08,       # Hedge when drawdown > 8%\n            'var_threshold': 0.05              # Hedge when VaR > 5%\n        }\n        \n        # Hedge instruments (simplified)\n        self.hedge_instruments = {\n            'short_futures': {\n                'symbols': ['BTC-PERP', 'ETH-PERP'],\n                'cost_bps': 5,  # 5 basis points cost\n                'effectiveness': 0.9\n            },\n            'put_options': {\n                'symbols': ['BTC-PUT', 'ETH-PUT'],\n                'cost_bps': 15,  # 15 basis points cost\n                'effectiveness': 0.8\n            },\n            'correlation_hedge': {\n                'symbols': ['CORRELATION-BASKET'],\n                'cost_bps': 8,\n                'effectiveness': 0.7\n            }\n        }\n    \n    def analyze_hedge_needs(self, \n                          portfolio_positions: Dict,\n                          market_data: Dict,\n                          risk_metrics: Dict) -> List[HedgeRecommendation]:\n        \"\"\"\n        Analyze portfolio and recommend hedging strategies\n        \n        Args:\n            portfolio_positions: Current portfolio positions\n            market_data: Market data for all assets\n            risk_metrics: Portfolio risk metrics\n            \n        Returns:\n            List of hedge recommendations\n        \"\"\"\n        try:\n            recommendations = []\n            \n            # Calculate portfolio exposure metrics\n            exposure_metrics = self._calculate_exposure_metrics(portfolio_positions, market_data)\n            \n            # Check for beta hedging needs\n            beta_hedge = self._check_beta_hedge(exposure_metrics, risk_metrics)\n            if beta_hedge:\n                recommendations.append(beta_hedge)\n            \n            # Check for correlation hedging needs\n            correlation_hedge = self._check_correlation_hedge(exposure_metrics, market_data)\n            if correlation_hedge:\n                recommendations.append(correlation_hedge)\n            \n            # Check for volatility hedging needs\n            volatility_hedge = self._check_volatility_hedge(exposure_metrics, risk_metrics)\n            if volatility_hedge:\n                recommendations.append(volatility_hedge)\n            \n            # Check for tail risk hedging\n            tail_risk_hedge = self._check_tail_risk_hedge(exposure_metrics, risk_metrics)\n            if tail_risk_hedge:\n                recommendations.append(tail_risk_hedge)\n            \n            # Check for sector/theme concentration hedging\n            concentration_hedge = self._check_concentration_hedge(exposure_metrics)\n            if concentration_hedge:\n                recommendations.append(concentration_hedge)\n            \n            logger.info(f\"Generated {len(recommendations)} hedge recommendations\")\n            return recommendations\n            \n        except Exception as e:\n            logger.error(f\"Error analyzing hedge needs: {e}\")\n            return []\n    \n    def _calculate_exposure_metrics(self, positions: Dict, market_data: Dict) -> Dict:\n        \"\"\"Calculate portfolio exposure metrics\"\"\"\n        try:\n            total_value = sum(\n                pos['size'] * pos.get('current_price', pos['entry_price'])\n                for pos in positions.values()\n            )\n            \n            # Calculate individual exposures\n            exposures = {}\n            for symbol, position in positions.items():\n                current_price = position.get('current_price', position['entry_price'])\n                value = position['size'] * current_price\n                exposures[symbol] = {\n                    'weight': value / total_value if total_value > 0 else 0,\n                    'value': value,\n                    'beta': self._estimate_beta(symbol, market_data),\n                    'volatility': self._estimate_volatility(symbol, market_data)\n                }\n            \n            # Calculate portfolio-level metrics\n            portfolio_beta = sum(\n                exp['weight'] * exp['beta'] \n                for exp in exposures.values()\n            )\n            \n            portfolio_volatility = np.sqrt(sum(\n                (exp['weight'] * exp['volatility']) ** 2 \n                for exp in exposures.values()\n            ))\n            \n            # Concentration metrics\n            weights = [exp['weight'] for exp in exposures.values()]\n            max_weight = max(weights) if weights else 0\n            herfindahl_index = sum(w**2 for w in weights)\n            \n            return {\n                'total_value': total_value,\n                'individual_exposures': exposures,\n                'portfolio_beta': portfolio_beta,\n                'portfolio_volatility': portfolio_volatility,\n                'max_weight': max_weight,\n                'concentration_index': herfindahl_index,\n                'effective_positions': 1 / herfindahl_index if herfindahl_index > 0 else 0\n            }\n            \n        except Exception as e:\n            logger.error(f\"Error calculating exposure metrics: {e}\")\n            return {}\n    \n    def _estimate_beta(self, symbol: str, market_data: Dict) -> float:\n        \"\"\"Estimate asset beta (simplified)\"\"\"\n        try:\n            # Simplified beta estimation\n            # In practice, would calculate against market benchmark\n            \n            if 'BTC' in symbol:\n                return 1.0  # Bitcoin as market proxy\n            elif 'ETH' in symbol:\n                return 1.2  # Ethereum typically higher beta\n            elif 'SOL' in symbol or 'AVAX' in symbol:\n                return 1.5  # Alt coins higher beta\n            else:\n                return 1.1  # Default\n                \n        except Exception as e:\n            logger.error(f\"Error estimating beta for {symbol}: {e}\")\n            return 1.0\n    \n    def _estimate_volatility(self, symbol: str, market_data: Dict) -> float:\n        \"\"\"Estimate asset volatility (simplified)\"\"\"\n        try:\n            # Simplified volatility estimation\n            # In practice, would calculate from historical returns\n            \n            if 'BTC' in symbol:\n                return 0.6  # 60% annual volatility\n            elif 'ETH' in symbol:\n                return 0.8  # 80% annual volatility\n            else:\n                return 1.0  # 100% for alts\n                \n        except Exception as e:\n            logger.error(f\"Error estimating volatility for {symbol}: {e}\")\n            return 0.6\n    \n    def _check_beta_hedge(self, exposure_metrics: Dict, risk_metrics: Dict) -> Optional[HedgeRecommendation]:\n        \"\"\"Check if beta hedging is needed\"\"\"\n        try:\n            portfolio_beta = exposure_metrics.get('portfolio_beta', 0)\n            \n            if portfolio_beta > self.hedge_thresholds['portfolio_beta_threshold']:\n                # Calculate hedge size to reduce beta to 1.0\n                target_beta = 1.0\n                excess_beta = portfolio_beta - target_beta\n                portfolio_value = exposure_metrics.get('total_value', 0)\n                \n                hedge_ratio = excess_beta / portfolio_beta\n                hedge_size = portfolio_value * hedge_ratio\n                \n                return HedgeRecommendation(\n                    hedge_type='beta_hedge',\n                    symbol='BTC-PERP',  # Use BTC perpetual as hedge\n                    side='sell',\n                    size=hedge_size / 50000,  # Assume $50k BTC price\n                    hedge_ratio=hedge_ratio,\n                    reason=f'Portfolio beta {portfolio_beta:.2f} exceeds threshold {self.hedge_thresholds[\"portfolio_beta_threshold\"]}',\n                    urgency='medium',\n                    expected_cost=hedge_size * 0.0005,  # 5 bps cost\n                    expected_protection=hedge_size * 0.8  # 80% effectiveness\n                )\n            \n            return None\n            \n        except Exception as e:\n            logger.error(f\"Error checking beta hedge: {e}\")\n            return None\n    \n    def _check_correlation_hedge(self, exposure_metrics: Dict, market_data: Dict) -> Optional[HedgeRecommendation]:\n        \"\"\"Check if correlation hedging is needed\"\"\"\n        try:\n            # Calculate average correlation between positions\n            exposures = exposure_metrics.get('individual_exposures', {})\n            \n            if len(exposures) < 2:\n                return None\n            \n            # Simplified correlation calculation\n            # In practice, would use historical correlation matrix\n            symbols = list(exposures.keys())\n            correlations = []\n            \n            for i, symbol1 in enumerate(symbols):\n                for j, symbol2 in enumerate(symbols[i+1:], i+1):\n                    # Estimate correlation based on asset types\n                    if ('BTC' in symbol1 and 'ETH' in symbol2) or ('ETH' in symbol1 and 'BTC' in symbol2):\n                        corr = 0.7\n                    elif 'BTC' in symbol1 or 'BTC' in symbol2:\n                        corr = 0.6\n                    else:\n                        corr = 0.8  # High correlation between alts\n                    \n                    correlations.append(corr)\n            \n            avg_correlation = np.mean(correlations) if correlations else 0\n            \n            if avg_correlation > self.hedge_thresholds['correlation_threshold']:\n                portfolio_value = exposure_metrics.get('total_value', 0)\n                hedge_ratio = 0.2  # Hedge 20% of portfolio\n                hedge_size = portfolio_value * hedge_ratio\n                \n                return HedgeRecommendation(\n                    hedge_type='correlation_hedge',\n                    symbol='CORRELATION-BASKET',\n                    side='sell',\n                    size=hedge_size,\n                    hedge_ratio=hedge_ratio,\n                    reason=f'Average correlation {avg_correlation:.2f} exceeds threshold {self.hedge_thresholds[\"correlation_threshold\"]}',\n                    urgency='low',\n                    expected_cost=hedge_size * 0.0008,  # 8 bps cost\n                    expected_protection=hedge_size * 0.7  # 70% effectiveness\n                )\n            \n            return None\n            \n        except Exception as e:\n            logger.error(f\"Error checking correlation hedge: {e}\")\n            return None\n    \n    def _check_volatility_hedge(self, exposure_metrics: Dict, risk_metrics: Dict) -> Optional[HedgeRecommendation]:\n        \"\"\"Check if volatility hedging is needed\"\"\"\n        try:\n            portfolio_volatility = exposure_metrics.get('portfolio_volatility', 0)\n            \n            if portfolio_volatility > self.hedge_thresholds['volatility_threshold']:\n                portfolio_value = exposure_metrics.get('total_value', 0)\n                \n                # Calculate hedge to reduce volatility\n                target_volatility = self.hedge_thresholds['volatility_threshold']\n                vol_reduction_needed = portfolio_volatility - target_volatility\n                hedge_ratio = vol_reduction_needed / portfolio_volatility\n                hedge_size = portfolio_value * hedge_ratio\n                \n                return HedgeRecommendation(\n                    hedge_type='volatility_hedge',\n                    symbol='BTC-PUT',  # Use put options for vol hedge\n                    side='buy',\n                    size=hedge_size / 50000,  # Convert to BTC terms\n                    hedge_ratio=hedge_ratio,\n                    reason=f'Portfolio volatility {portfolio_volatility:.2%} exceeds threshold {self.hedge_thresholds[\"volatility_threshold\"]:.2%}',\n                    urgency='medium',\n                    expected_cost=hedge_size * 0.0015,  # 15 bps cost for options\n                    expected_protection=hedge_size * 0.8\n                )\n            \n            return None\n            \n        except Exception as e:\n            logger.error(f\"Error checking volatility hedge: {e}\")\n            return None\n    \n    def _check_tail_risk_hedge(self, exposure_metrics: Dict, risk_metrics: Dict) -> Optional[HedgeRecommendation]:\n        \"\"\"Check if tail risk hedging is needed\"\"\"\n        try:\n            # Check VaR and current drawdown\n            var_95 = risk_metrics.get('var_95', 0)\n            current_drawdown = risk_metrics.get('current_drawdown', 0)\n            \n            if abs(var_95) > self.hedge_thresholds['var_threshold'] or current_drawdown > self.hedge_thresholds['drawdown_threshold']:\n                portfolio_value = exposure_metrics.get('total_value', 0)\n                hedge_ratio = 0.1  # Tail risk hedge 10% of portfolio\n                hedge_size = portfolio_value * hedge_ratio\n                \n                return HedgeRecommendation(\n                    hedge_type='tail_risk_hedge',\n                    symbol='BTC-PUT',\n                    side='buy',\n                    size=hedge_size / 50000,\n                    hedge_ratio=hedge_ratio,\n                    reason=f'VaR {abs(var_95):.2%} or drawdown {current_drawdown:.2%} exceeds thresholds',\n                    urgency='high',\n                    expected_cost=hedge_size * 0.002,  # 20 bps for tail protection\n                    expected_protection=hedge_size * 0.9\n                )\n            \n            return None\n            \n        except Exception as e:\n            logger.error(f\"Error checking tail risk hedge: {e}\")\n            return None\n    \n    def _check_concentration_hedge(self, exposure_metrics: Dict) -> Optional[HedgeRecommendation]:\n        \"\"\"Check if concentration hedging is needed\"\"\"\n        try:\n            max_weight = exposure_metrics.get('max_weight', 0)\n            \n            if max_weight > 0.4:  # If single position > 40%\n                # Find the largest position\n                exposures = exposure_metrics.get('individual_exposures', {})\n                largest_position = max(exposures.items(), key=lambda x: x[1]['weight'])\n                symbol, exposure = largest_position\n                \n                portfolio_value = exposure_metrics.get('total_value', 0)\n                hedge_ratio = 0.5  # Hedge 50% of the concentrated position\n                hedge_size = exposure['value'] * hedge_ratio\n                \n                return HedgeRecommendation(\n                    hedge_type='concentration_hedge',\n                    symbol=f'{symbol}-PERP',\n                    side='sell',\n                    size=hedge_size / exposure.get('current_price', 50000),\n                    hedge_ratio=hedge_ratio,\n                    reason=f'Position {symbol} represents {max_weight:.1%} of portfolio',\n                    urgency='medium',\n                    expected_cost=hedge_size * 0.0005,\n                    expected_protection=hedge_size * 0.9\n                )\n            \n            return None\n            \n        except Exception as e:\n            logger.error(f\"Error checking concentration hedge: {e}\")\n            return None\n    \n    async def execute_hedge(self, recommendation: HedgeRecommendation, order_executor) -> Dict:\n        \"\"\"Execute a hedge recommendation\"\"\"\n        try:\n            logger.info(f\"Executing {recommendation.hedge_type} hedge: {recommendation.symbol} {recommendation.side} {recommendation.size:.4f}\")\n            \n            # Execute hedge order\n            order_result = await order_executor.place_order(\n                symbol=recommendation.symbol,\n                side=recommendation.side,\n                size=recommendation.size,\n                order_type='market',\n                metadata={\n                    'hedge_type': recommendation.hedge_type,\n                    'hedge_ratio': recommendation.hedge_ratio,\n                    'reason': recommendation.reason\n                }\n            )\n            \n            if order_result['status'] in ['filled', 'partial']:\n                # Record hedge position\n                hedge_id = f\"hedge_{recommendation.hedge_type}_{int(datetime.now().timestamp())}\"\n                \n                hedge_position = {\n                    'hedge_id': hedge_id,\n                    'hedge_type': recommendation.hedge_type,\n                    'symbol': recommendation.symbol,\n                    'side': recommendation.side,\n                    'size': order_result.get('filled_size', recommendation.size),\n                    'entry_price': order_result.get('fill_price', 0),\n                    'hedge_ratio': recommendation.hedge_ratio,\n                    'timestamp': datetime.now(),\n                    'status': 'active',\n                    'reason': recommendation.reason,\n                    'expected_cost': recommendation.expected_cost,\n                    'expected_protection': recommendation.expected_protection\n                }\n                \n                self.hedge_positions[hedge_id] = hedge_position\n                self.hedge_history.append(hedge_position.copy())\n                \n                logger.info(f\"Hedge executed successfully: {hedge_id}\")\n                \n                return {\n                    'status': 'success',\n                    'hedge_id': hedge_id,\n                    'hedge_position': hedge_position\n                }\n            else:\n                return {\n                    'status': 'failed',\n                    'reason': 'Order not filled',\n                    'order_result': order_result\n                }\n                \n        except Exception as e:\n            logger.error(f\"Error executing hedge: {e}\")\n            return {\n                'status': 'error',\n                'error': str(e)\n            }\n    \n    def update_hedge_positions(self, current_prices: Dict):\n        \"\"\"Update hedge position values and P&L\"\"\"\n        try:\n            for hedge_id, position in self.hedge_positions.items():\n                if position['status'] != 'active':\n                    continue\n                \n                symbol = position['symbol']\n                current_price = current_prices.get(symbol, position['entry_price'])\n                \n                # Calculate P&L\n                if position['side'] == 'buy':\n                    pnl = (current_price - position['entry_price']) * position['size']\n                else:  # sell\n                    pnl = (position['entry_price'] - current_price) * position['size']\n                \n                position['current_price'] = current_price\n                position['unrealized_pnl'] = pnl\n                position['last_updated'] = datetime.now()\n                \n        except Exception as e:\n            logger.error(f\"Error updating hedge positions: {e}\")\n    \n    def close_hedge(self, hedge_id: str, order_executor) -> Dict:\n        \"\"\"Close a hedge position\"\"\"\n        try:\n            if hedge_id not in self.hedge_positions:\n                return {'status': 'error', 'message': 'Hedge not found'}\n            \n            position = self.hedge_positions[hedge_id]\n            \n            if position['status'] != 'active':\n                return {'status': 'error', 'message': 'Hedge not active'}\n            \n            # Close hedge by taking opposite position\n            close_side = 'sell' if position['side'] == 'buy' else 'buy'\n            \n            # This would execute the closing order\n            # For now, just mark as closed\n            position['status'] = 'closed'\n            position['close_timestamp'] = datetime.now()\n            \n            logger.info(f\"Hedge {hedge_id} closed\")\n            \n            return {'status': 'success', 'hedge_id': hedge_id}\n            \n        except Exception as e:\n            logger.error(f\"Error closing hedge {hedge_id}: {e}\")\n            return {'status': 'error', 'error': str(e)}\n    \n    def get_hedge_effectiveness_report(self) -> Dict:\n        \"\"\"Generate hedge effectiveness report\"\"\"\n        try:\n            if not self.hedge_history:\n                return {'message': 'No hedge history available'}\n            \n            # Analyze hedge performance\n            total_hedges = len(self.hedge_history)\n            active_hedges = len([h for h in self.hedge_positions.values() if h['status'] == 'active'])\n            \n            # Calculate costs and protection\n            total_cost = sum(h.get('expected_cost', 0) for h in self.hedge_history)\n            total_protection = sum(h.get('expected_protection', 0) for h in self.hedge_history)\n            \n            # Hedge type breakdown\n            hedge_types = {}\n            for hedge in self.hedge_history:\n                hedge_type = hedge['hedge_type']\n                if hedge_type not in hedge_types:\n                    hedge_types[hedge_type] = 0\n                hedge_types[hedge_type] += 1\n            \n            return {\n                'total_hedges': total_hedges,\n                'active_hedges': active_hedges,\n                'total_cost': total_cost,\n                'total_protection': total_protection,\n                'cost_efficiency': total_protection / total_cost if total_cost > 0 else 0,\n                'hedge_type_breakdown': hedge_types,\n                'average_hedge_ratio': np.mean([h.get('hedge_ratio', 0) for h in self.hedge_history])\n            }\n            \n        except Exception as e:\n            logger.error(f\"Error generating hedge effectiveness report: {e}\")\n            return {'error': str(e)}\n    \n    def update_hedge_thresholds(self, new_thresholds: Dict):\n        \"\"\"Update hedging thresholds\"\"\"\n        try:\n            self.hedge_thresholds.update(new_thresholds)\n            logger.info(f\"Hedge thresholds updated: {new_thresholds}\")\n        except Exception as e:\n            logger.error(f\"Error updating hedge thresholds: {e}\")\n\n# Example usage\nif __name__ == '__main__':\n    # Test the hedging system\n    hedging_system = DynamicHedgingSystem()\n    \n    # Mock portfolio positions\n    positions = {\n        'BTC-USD': {\n            'size': 2.0,\n            'entry_price': 45000,\n            'current_price': 47000,\n            'side': 'long'\n        },\n        'ETH-USD': {\n            'size': 10.0,\n            'entry_price': 3200,\n            'current_price': 3300,\n            'side': 'long'\n        }\n    }\n    \n    # Mock risk metrics\n    risk_metrics = {\n        'var_95': 0.06,\n        'current_drawdown': 0.12\n    }\n    \n    # Analyze hedge needs\n    recommendations = hedging_system.analyze_hedge_needs(\n        positions, {}, risk_metrics\n    )\n    \n    print(f\"Generated {len(recommendations)} hedge recommendations:\")\n    for rec in recommendations:\n        print(f\"- {rec.hedge_type}: {rec.symbol} {rec.side} {rec.size:.4f} ({rec.urgency} urgency)\")\n        print(f\"  Reason: {rec.reason}\")\n        print(f\"  Cost: ${rec.expected_cost:.2f}, Protection: ${rec.expected_protection:.2f}\")\n