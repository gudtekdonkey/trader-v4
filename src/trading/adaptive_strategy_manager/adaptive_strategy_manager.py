"""
File: adaptive_strategy_manager.py
Modified: 2024-12-19
Refactored: 2025-07-18

Dynamic strategy allocation with modular architecture.
This file coordinates the strategy management modules for better maintainability.
"""

import numpy as np
from typing import Dict, List, Optional, Tuple, Any
import traceback

# Import strategy management modules
from modules.strategy_allocation import StrategyAllocation, RegimeBasedAllocator
from modules.performance_tracker import PerformanceTracker
from modules.allocation_adjuster import AllocationAdjuster

from risk_manager import RiskManager
from utils.logger import setup_logger

logger = setup_logger(__name__)


class AdaptiveStrategyManager:
    """
    Dynamic strategy allocation based on market regimes and conditions.
    
    This class manages the allocation of capital across different trading strategies
    based on current market conditions, regime detection, and historical performance.
    It adapts allocations dynamically to optimize returns while managing risk.
    
    Attributes:
        risk_manager: Risk management instance
        regime_allocator: Handles regime-based allocation logic
        performance_tracker: Tracks strategy performance
        allocation_adjuster: Handles dynamic adjustments
        learning_rate: Rate of adaptation based on performance
        min_confidence_threshold: Minimum regime confidence for full allocation
    """
    
    def __init__(self, risk_manager: RiskManager) -> None:
        """
        Initialize the Adaptive Strategy Manager.
        
        Args:
            risk_manager: Instance of RiskManager for risk calculations
        """
        # Validate risk manager
        if not risk_manager:
            raise ValueError("Risk manager is required")
            
        self.risk_manager = risk_manager
        
        try:
            # Initialize modules
            self.regime_allocator = RegimeBasedAllocator()
            self.performance_tracker = PerformanceTracker()
            self.allocation_adjuster = AllocationAdjuster(learning_rate=0.05)
            
            # Adaptive learning parameters
            self.learning_rate: float = 0.05
            self.min_confidence_threshold: float = 0.3
            
            logger.info("Adaptive Strategy Manager initialized successfully")
            
        except Exception as e:
            logger.error(f"Error initializing Adaptive Strategy Manager: {e}")
            raise
    
    def get_optimal_allocation(self, regime_info: Dict[str, Any], 
                             market_conditions: Dict[str, float], 
                             strategy_signals: Dict[str, List]) -> List[StrategyAllocation]:
        """
        Get optimal strategy allocation based on current conditions.
        
        This method combines regime-based allocation with performance adjustment,
        market conditions, and signal strength to determine optimal strategy weights.
        
        Args:
            regime_info: Dictionary containing regime type and confidence
            market_conditions: Current market metrics (volatility, volume, trend)
            strategy_signals: Signals generated by each strategy
            
        Returns:
            List of StrategyAllocation objects with normalized weights
        """
        try:
            # Validate and normalize inputs
            regime_info = self._validate_regime_info(regime_info)
            market_conditions = self._validate_market_conditions(market_conditions)
            strategy_signals = strategy_signals or {}
            
            # Extract regime information
            regime = regime_info.get('regime', 1)
            regime_confidence = regime_info.get('confidence', 0.7)
            
            # Map regime to name
            regime_name = self.regime_allocator.map_regime_to_name(regime)
            
            # Get base allocation for regime
            base_allocation = self.regime_allocator.get_base_allocation(regime_name)
            
            # Apply performance adjustment
            performance_scores = self.performance_tracker.get_performance_scores(
                list(base_allocation.keys())
            )
            performance_adjusted = self.allocation_adjuster.adjust_for_performance(
                base_allocation, performance_scores
            )
            
            # Apply market condition adjustments
            market_adjusted = self.allocation_adjuster.adjust_for_market_conditions(
                performance_adjusted, market_conditions
            )
            
            # Apply signal strength adjustments
            signal_adjusted = self.allocation_adjuster.adjust_for_signal_strength(
                market_adjusted, strategy_signals
            )
            
            # Apply regime confidence
            final_allocation = self.regime_allocator.apply_regime_confidence(
                signal_adjusted, regime_confidence, self.min_confidence_threshold
            )
            
            # Normalize allocation
            final_allocation = self.allocation_adjuster.normalize_allocation(final_allocation)
            
            # Create allocation objects
            allocations = self._create_allocation_objects(
                final_allocation, regime_info, market_conditions, performance_scores
            )
            
            # Ensure we have at least one allocation
            if not allocations:
                allocations = self._get_fallback_allocation()
            
            # Log allocation decision
            self._log_allocation_decision(regime_name, regime_confidence, allocations)
            
            return allocations
            
        except Exception as e:
            logger.error(f"Critical error in get_optimal_allocation: {e}")
            logger.error(traceback.format_exc())
            
            # Return safe fallback allocation
            return self._get_fallback_allocation()
    
    def _validate_regime_info(self, regime_info: Optional[Dict[str, Any]]) -> Dict[str, Any]:
        """Validate and normalize regime information"""
        if not regime_info:
            logger.warning("No regime info provided, using default")
            return {'regime': 1, 'confidence': 0.5}
            
        # Validate regime bounds
        regime = regime_info.get('regime', 1)
        regime = max(0, min(regime, 3))  # Ensure valid regime index
        
        # Validate confidence
        confidence = regime_info.get('confidence', 0.7)
        confidence = max(0.0, min(1.0, confidence))
        
        return {'regime': regime, 'confidence': confidence}
    
    def _validate_market_conditions(self, market_conditions: Optional[Dict[str, float]]) -> Dict[str, float]:
        """Validate and normalize market conditions"""
        if not market_conditions:
            logger.warning("No market conditions provided, using defaults")
            return {'volatility': 0.02, 'volume_ratio': 1.0, 'trend_strength': 0.0}
            
        # Validate individual conditions
        validated = {}
        validated['volatility'] = max(0.0, min(1.0, market_conditions.get('volatility', 0.02)))
        validated['volume_ratio'] = max(0.1, min(10.0, market_conditions.get('volume_ratio', 1.0)))
        validated['trend_strength'] = max(-1.0, min(1.0, market_conditions.get('trend_strength', 0.0)))
        
        return validated
    
    def _create_allocation_objects(self, final_allocation: Dict[str, float],
                                 regime_info: Dict[str, Any],
                                 market_conditions: Dict[str, float],
                                 performance_scores: Dict[str, float]) -> List[StrategyAllocation]:
        """Create StrategyAllocation objects from final weights"""
        allocations = []
        
        for strategy, weight in final_allocation.items():
            # Validate weight
            weight = max(0.0, min(1.0, weight))
            
            if weight > 0.01:  # Only include strategies with >1% allocation
                try:
                    # Calculate strategy metrics
                    confidence = self.allocation_adjuster.calculate_strategy_confidence(
                        strategy, 
                        regime_info['confidence'],
                        performance_scores.get(strategy, 1.0),
                        market_conditions.get('volatility', 0.02)
                    )
                    
                    expected_return = self.regime_allocator.estimate_expected_return(
                        strategy, market_conditions.get('volatility', 0.02)
                    )
                    
                    risk_score = self.regime_allocator.calculate_strategy_risk(
                        strategy, market_conditions.get('volatility', 0.02)
                    )
                    
                    allocation = StrategyAllocation(
                        strategy_name=strategy,
                        weight=weight,
                        confidence=confidence,
                        expected_return=expected_return,
                        risk_score=risk_score
                    )
                    allocations.append(allocation)
                    
                except Exception as e:
                    logger.error(f"Error creating allocation for {strategy}: {e}")
                    continue
        
        return allocations
    
    def _get_fallback_allocation(self) -> List[StrategyAllocation]:
        """Get safe fallback allocation"""
        logger.warning("Using fallback allocation")
        return [
            StrategyAllocation(
                strategy_name='arbitrage',  # Safest strategy
                weight=1.0,
                confidence=0.3,
                expected_return=0.05,
                risk_score=25
            )
        ]
    
    def update_strategy_performance(self, strategy: str, trade_return: float) -> None:
        """
        Update strategy performance tracking.
        
        Args:
            strategy: Strategy name
            trade_return: Return from the trade
        """
        self.performance_tracker.update_performance(strategy, trade_return)
    
    def _log_allocation_decision(self, regime: str, regime_confidence: float, 
                               allocations: List[StrategyAllocation]) -> None:
        """Log allocation decision for analysis"""
        try:
            allocation_str = ", ".join([
                f"{a.strategy_name}: {a.weight:.2%}" 
                for a in allocations
            ])
            logger.info(
                f"Strategy allocation for {regime} regime "
                f"(conf: {regime_confidence:.2f}): {allocation_str}"
            )
        except Exception as e:
            logger.error(f"Error logging allocation decision: {e}")
    
    def get_allocation_analytics(self) -> Dict[str, Any]:
        """
        Get analytics on strategy allocation decisions.
        
        Returns:
            Dictionary containing performance metrics and rankings
        """
        try:
            analytics = self.performance_tracker.get_analytics()
            analytics['learning_rate'] = self.learning_rate
            analytics['min_confidence_threshold'] = self.min_confidence_threshold
            
            return analytics
            
        except Exception as e:
            logger.error(f"Error getting allocation analytics: {e}")
            return {
                'error': str(e),
                'strategy_performance': {},
                'current_rankings': {}
            }
    
    def select_best_signal(self, signals: List[Any], market_data: Dict[str, Any],
                         ml_predictions: Dict[str, Any]) -> Optional[Any]:
        """
        Select the best signal from multiple strategies.
        
        This method is used by the main trading loop to choose which signal to execute.
        
        Args:
            signals: List of signals from different strategies
            market_data: Current market data
            ml_predictions: ML model predictions
            
        Returns:
            Best signal to execute, or None
        """
        if not signals:
            return None
            
        try:
            # Get current regime from ML predictions
            regime_info = {
                'regime': ml_predictions.get('regime', 1),
                'confidence': ml_predictions.get('regime_confidence', 0.7)
            }
            
            # Extract market conditions
            market_conditions = {
                'volatility': market_data.get('current', {}).get('volatility', 0.02),
                'volume_ratio': market_data.get('current', {}).get('volume_ratio', 1.0),
                'trend_strength': market_data.get('current', {}).get('trend_strength', 0.0)
            }
            
            # Get optimal allocation
            allocations = self.get_optimal_allocation(regime_info, market_conditions, {})
            
            # Create strategy weight map
            strategy_weights = {a.strategy_name: a.weight for a in allocations}
            
            # Score each signal
            best_signal = None
            best_score = -float('inf')
            
            for signal in signals:
                if hasattr(signal, 'type') and hasattr(signal, 'confidence'):
                    strategy_type = getattr(signal, 'type', 'unknown')
                    base_weight = strategy_weights.get(strategy_type, 0.1)
                    signal_confidence = getattr(signal, 'confidence', 0.5)
                    
                    # Calculate signal score
                    score = base_weight * signal_confidence
                    
                    if score > best_score:
                        best_score = score
                        best_signal = signal
            
            return best_signal
            
        except Exception as e:
            logger.error(f"Error selecting best signal: {e}")
            # Return first signal as fallback
            return signals[0] if signals else None

    # Compatibility properties for backward compatibility
    @property
    def regime_strategies(self) -> Dict[str, Dict[str, float]]:
        """Get regime strategies for backward compatibility"""
        return self.regime_allocator.regime_strategies
    
    @property
    def strategy_performance(self) -> Dict[str, Dict[str, Any]]:
        """Get strategy performance for backward compatibility"""
        return self.performance_tracker.strategy_performance
    
    @property
    def performance_window(self) -> int:
        """Get performance window for backward compatibility"""
        return self.performance_tracker.performance_window

"""
REFACTORING SUMMARY:
- Original file: 900+ lines
- Refactored adaptive_strategy_manager.py: ~350 lines
- Created 3 modular components:
  1. strategy_allocation.py - Regime-based allocation and risk calculations
  2. performance_tracker.py - Performance tracking and scoring
  3. allocation_adjuster.py - Dynamic adjustments and normalization
- Benefits:
  * Clear separation of allocation logic
  * Easier to test performance tracking
  * Simplified adjustment mechanisms
  * Better maintainability
  * Preserved all original functionality
"""
